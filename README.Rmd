---
title: "CyTOF Pipeline"
output: github_document
always_allow_html: true
---

**This README has two parts: The Shiny App and an example analysis** 

# Part 1: Shiny App

The docker image for our shiny app is publicly available at [...]. 
First, make sure docker is installed on your machine. Then run

```{bash docker pull, eval = FALSE}
docker pull quirinmanz/cytof_pipeline
```

If you want to use the [PBMC example data](https://www.nature.com/articles/nbt.2317), you can download it from our [Google Drive](https://drive.google.com/drive/folders/19hM51eoLLEJDQ_Oz4xqMu2t9bAY9Qcyf?usp=sharing).
Then run

```{bash include pbmc, eval = FALSE}
mkdir myData
mv -r path/to/pbmcData myData
docker run --rm -p 3838:3838 -v /absolute/path/to/myData:/srv/cytof_pipeline/data cytof_pipeline
```

in order to connect the data folder with the downloaded data to the repository.

If you go to localhost:3838, you can see our Shiny app. 

You can also run the Shiny App in your R session with `shiny::runApp()`. In that case, you have to restore the project library using [renv](https://rstudio.github.io/renv/articles/renv.html): 

```{r renv, eval = FALSE}
# install.packages('renv')
renv::restore()
```

# Part 2: Example analysis

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width=12, fig.height=8)
library(data.table)
library(CATALYST)
library(flowCore)
library(ggplot2)
library(SingleCellExperiment)
library(readxl)
library(diffcyt)
library(RColorBrewer)
library(grid)
library(futile.logger)
library(VennDiagram)
library(stringr)
set.seed(1234)

source("pipeline/shiny_functions.R")
source("server/clusterFun.R")
```


Data from human platelets of patients with chronic coronary syndrome undergoing different therapy: dual antiplatelet therapy versus triple antiplatelet therapy, before and after platelet activation with 10Âµm TRAP. There are files of 7 patients with triple therapy and 12 patients with dual therapy (each in two conditions). For information about how to create a SCE object, please refer to the [CATALYST Vignette](https://www.bioconductor.org/packages/release/bioc/html/CATALYST.html)

# Read in SCE object

This SCE object contains 10 000 cells per sample and therefore 20 000 cells per patient. 

```{r load sce}
sce <- readRDS("data/platelets_small/sce.rds")
metadata(sce)$experiment_info
```

# Quality Control

```{r diagnostic plots, fig.width=12, fig.height=8}
CATALYST::pbMDS(
      sce,
      label_by = "patient_id", 
      color_by = "activated_baseline",
      features = NULL, # possible inputs: unique(rowData(sce)$marker_class) or NULL (to use all features)
      assay = "exprs", # possible inputs: assayNames(sce)
    ) + theme(text = element_text(size=18))

CATALYST::plotNRS(
      sce,
      color_by = "activated_baseline",
      features = NULL,
      assay = "exprs"
    )

CATALYST::plotExprs(
      sce,
      color_by = "activated_baseline",
      features = NULL,
      assay = "exprs"
    )  + theme(text = element_text(size=18))

plotExprHeatmap(
      sce,
      features = NULL,
      assay = "exprs"
    )
CATALYST::plotCounts(
    sce,
    group_by = "patient_id", # possible inputs: names(colData(sce))
    color_by = "dual_triple", # possible inputs: names(colData(sce))
    prop = FALSE # TRUE for stacked relative abundances, FALSE for total cell counts
  ) 
```
We can see that sample 99 does not cluster with the other activated samples in the MDS plot. We can also see in the expression plot, that the expressions for 99 baseline and 99 activated are nearly the same. We therefore exclude the patient from our analysis.
```{r remove 99}
sce <- makePatientSelection(sce = sce, deselected_patients = c("RPS 099"))
```

The next step of quality control is clustering:
```{r clustering QC}
sce <- clusterSCE(sce)
plotly::ggplotly(delta_area(sce))
```
Let's have a look at meta 7:
```{r plot abundances QC}
CATALYST::plotAbundances(sce, "meta7", group_by = "activated_baseline") +  theme(text = element_text(size=18), axis.text.x = element_text(size=12)) 
```
As we can see, clusters 5,6, and 7 were mainly made because of sample 96. Therefore, we also exclude this sample: 
```{r exclude 96}
sce <- makePatientSelection(sce = sce, deselected_patients = c("RPS 096"))
```
We cluster again in order to see if the delta area changed and if the cluster abundances now look good:
```{r clustering}
sce <- clusterSCE(sce)
plotly::ggplotly(delta_area(sce))
```
We do not seem to win much by looking at more than 7 clusters. Let's take a look at meta7 again. 
We can also make a star plot to compare the marker abundances:
```{r clustering plots}
CATALYST::plotAbundances(sce, "meta7", group_by = "activated_baseline") +  theme(text = element_text(size=18), axis.text.x = element_text(size=12)) 
invisible(plotStarsCustom(sce, backgroundValues = cluster_codes(sce)[["meta7"]]))
```
The clustering now looks fine. We can therefore continue to do our analysis: 
# Data Visualization
You can now run various dimensionality reduction methods on your data. The options are (parameter dr_chosen): 
"UMAP", TSNE", "PCA", "MDS", "DiffusionMap" and "Isomap".


Other run options are:
cells_chosen: number of cells to sample from

feature_chosen: markers or marker class. We recommend using "type"

assay_chosen: "counts" or "exprs". We recommend using "exprs"

scale: TRUE or FALSE. We recommend using TRUE 

k: Isomap-specific parameter. Specifies the number of neighbours for the graph constructed by isomap

We try UMAP and PCA on our data and color by the expression of our state markers:
```{r dimensionality reduction}
DR_methods <- c("UMAP","PCA")

for( method in DR_methods ){
  sce <- runDimRed(sce, method, cells_chosen = 1000, feature_chosen = "type", assay_chosen = "exprs", scale = T)
}

state_markers <- rowData(sce)[rowData(sce)$marker_class=="state",]$marker_name
for( method in DR_methods ){
  g <- CATALYST::plotDR(sce, dr = method, color_by = state_markers, facet_by="activated_baseline") +  theme(text = element_text(size=18))
  print(g)
}
```

After clustering and visualization, we can move to the differential expression analysis.

# Differential Expression Analysis

We are especially interested in the markers that are differentially expressed between baseline and activation. Because we have two treatment groups, we make the differential expression analysis in these subgroups of patients: 

## Dual Activated vs. Dual Baseline
First, we have to filter the data to only dual patients.
```{r filter dual}
sce_d <- filterSCE(sce, dual_triple == "dual")
```

Before performing the differential marker expression analysis, we plot the median marker expressions.
```{r dual expressions,fig.with=12, fig.height=8}
CATALYST::plotPbExprs(sce_d, k = "all", features = NULL , color_by = "activated_baseline",  ncol=8, facet_by = "antigen") +  theme(text = element_text(size=16))
```

From this plot, we can see that our state markers CD63 and CD62P are probably differentially expressed but the state marker CD107a has a median marker expression of zero and the state marker CD154 just has one outlier sample that does not have a median marker expression of zero. 

We now perform out differential expression analysis with the LMM. We include patient_id as random effect such that the LMM can compare the marker expressions sample-wise
```{r LMM dual}
res_d <- runDS(sce = sce_d,
      condition = "activated_baseline",
      de_methods = c("LMM"),
      k = "all",
      features = "all",
      markers_to_test = "all",
      random_effect = "patient_id"
      )
```

Now, we can visualize that with a heatmap: 
```{r heatmap dual,fig.width=12, fig.height=8}
CATALYST::plotDiffHeatmap(sce_d, rowData(res_d$LMM$res), all=T, col_anno = c("activated_baseline", "patient_id"), normalize = TRUE)
```
As we expected, CD62P and CD63 are differentially expressed. Additionally, the LMM found the type markers PEAR, CD69, PAR1 and CD42a to be differentially expressed as well. 

## Triple Activated vs. Triple Baseline

We now subset our SCE object such that only the triple anticoagulation therapy patients are included: 
```{r filter triple}
sce_t <- filterSCE(sce, dual_triple == "triple")
```

```{r triple expressions,fig.with=12, fig.height=8}
CATALYST::plotPbExprs(sce_t, k = "all", features = NULL , color_by = "activated_baseline",  ncol=8, facet_by = "antigen") +  theme(text = element_text(size=16))
```
Again, we expect CD62P and CD63 to be differentially expressed. CD107a and CD154 again have a median marker expression in every sample except for one. 
```{r LMM triple}
res_t <- runDS(sce = sce_t,
      condition = "activated_baseline",
      de_methods = c("LMM"),
      k = "all",
      features = "all",
      random_effect = "patient_id"
      )

```

```{r heatmap triple,fig.with=12, fig.height=8}
CATALYST::plotDiffHeatmap(sce_t, rowData(res_t$LMM$res), all=T, col_anno = c("activated_baseline", "patient_id"), normalize = TRUE)
```
Here, we also find two type markers to be differentially expressed: PAR1 and CD42a. 

#Comparison of limma and LMM for Triple A vs. B

Lastly, let's compare which markers are found by limma and LMM:

```{r venn triple}
res_triple <- runDS(sce = sce_t,
      condition = "activated_baseline",
      random_effect = "patient_id",
      de_methods = c("limma","LMM"),
      k = "all",
      features = "all")


# significant markers found by all methods:
createVennDiagram(res_triple)
```
limma only finds the two state markers. When we look into the heatmap from the LMM and the boxplots of the median marker expression, we can see why: 
The difference between the median marker expressions does not look so different overall in the boxplots. This is the only thing that limma can evaluate. Because we tell the LMM to take the patient_id into account as an random effect, it compares the median marker expressions patient-wise. In the heatmap, the patient samples are shown next to each other. We can see that PAR1 and CD42a are downregulated for the activated platelets in each patient but the expressions per patient vary. This is why limma cannot find these two markers



